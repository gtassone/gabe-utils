package com.gmail.gtassone.util.chain;

/**
 * Pluggable behavior controller for the ChainManager. The ChainController
 * provides hooks for customized chain execution behavior.
 * 
 * @param <M>
 *        the type of ChainMessage handled by this Controller.
 * @author <a href=mailto:gtassone@gmail.com>gtassone</a>
 * @version $Revision$
 */
public interface ChainController<M extends ChainMessage> {

  /**
   * fired when processing starts for a message. this hook runs on the parent
   * thread.
   * 
   * @param message
   *        the message being processed.
   */
  void start(M message);

  /**
   * fired when a message reaches the end of the chain with no ChainHandlers
   * returning ChainHandlerResult.HANDLED.
   * 
   * @param message
   *        the sad message.
   */
  void handleUnhandledMessage(M message);

  /**
   * hook to handle a message for which a ChainHandler has returned
   * ChainHandlerResult.HANDLED.
   * 
   * @param message
   *        the message
   * @return true if the Controller implementation has custom logic to handle
   *         the Handled Message.
   */
  boolean handleHandledMessage(M message);

  /**
   * fired when a ChainHandlerResult.FAILURE is reported. The default
   * implementation {@link ChainController$Adapter} terminates the chain in this
   * case.
   * 
   * @param message
   *        the message being processed.
   * @return true if the Controller implementation has custom logic to handle
   *         the failure.
   */
  boolean handleReportedFailure(M message, ChainHandler<M> handler);

  /**
   * This method hook provides Handlers a direct means of indicating feedback
   * data for a submitted message. Since this architecture is not meant to
   * represent explicit Request/Response paradigm, a ChainController subclass
   * could implement Request/Response directly by wrapping
   * {@link #handleChainMessage(ChainMessage)} with a custom Chain invocation
   * method, therein blocking or maintaining a Callback to the client.
   * ChainHandlers with a handle to the ChainManager could then provide
   * Responses via ChainManager.result(). The result() implementation could also
   * potentially cancel the chain thread, although the handler should cancel the
   * thread by returning true.
   * 
   * @param handler
   *        the handler submitting the result
   * @param message
   *        The result message. This may be the original message, updated in
   *        some way, or a different message, generated by a Handler.
   */
  void submitResult(M message, ChainHandler<M> handler);

  /**
   * occurs when the Handler {@link ChainHandler#execute(ChainMessage)} method
   * runs for longer than the timeout constraint.
   * 
   * @param message
   *        the message that timed out
   * @param handler
   *        the handler that timed out
   */
  void handleTimeout(M message, ChainHandler<M> handler);

  /**
   * happens when {@link ChainHandler#execute(ChainMessage)} is interrupted for
   * some reason. this shouldn't happen during hte normal course of execution.
   * 
   * @param e
   *        the interrupt exception
   * @param message
   *        the message that was being processed when the thread was
   *        interrupted.
   * @param handler
   *        the handler executing when the thread was interrupted.
   */
  void handleInterruptedTask(InterruptedException e, M message,
      ChainHandler<M> handler);

  /**
   * fired when a ChainHandler finishes processing a message.
   * 
   * @param message
   *        the message being processed.
   * @param handler
   *        the Handler which just finished processing.
   */
  void handleTaskCompleted(M message, ChainHandler<M> handler);

  /**
   * fired when otherwise uncaught exceptions interrupt the execution of the
   * monitor thread.
   * 
   * @param e
   *        the exception thrown.
   * @param message
   *        the message being processed when the exception was thrown.
   * @param handler
   *        the Handler executing when the exception was thrown.
   */
  void handleMonitorException(Exception e, M message, ChainHandler<M> handler);

  /**
   * invoked for each submitted ChainMessage when its chain processing is
   * completed, either by executing every ChainHandler in the chain, or by a
   * ChainHandler returning true to indicate the ChainMessage has been handled.
   * 
   * @param message
   *        the message being processed.
   * @param handler
   *        the last Handler to execute.
   */
  void finish(M message, ChainHandler<M> handler);

  /**
   * indicates that there is a null value in the List of ChainHandlers for this
   * ChainManager. this should never happen.
   * 
   * @param message
   *        the message being processed.
   */
  void handleNullObject(M message);

  /**
   * fired when the next Handler is about to start processing.
   * 
   * @param message
   *        the message being processed.
   * @param nextHandler
   *        the Handler about to be executed.
   */
  void handleStartTask(M message, ChainHandler<M> nextHandler);

  /**
   * fired when a Handler throws an exception during
   * {@link ChainHandler#execute(ChainMessage)}.
   * 
   * @param e
   *        the exception thrown.
   * @param message
   *        the message being processed.
   * @param handler
   *        the Handler executing when the exception was thrown.
   */
  void handleDispatchException(Exception e, M message, ChainHandler<M> handler);

  /**
   * Utility adapter class for ChainController implementations which don't wish
   * to implement ever method.
   * 
   * @author <a href=mailto:gtassone@cougaarsoftware.com>gtassone</a>
   * @version $Revision$
   */
  public abstract class Adapter<M extends ChainMessage> implements
      ChainController<M> {

    private ChainManager<M, ? extends ChainController<M>> manager;

    /**
     * 0 argument constructor.
     */
    public Adapter() {

    }

    /**
     * Constructor sets the ChainManager for this Controller.
     * 
     * @param mgr
     *        the manager
     */
    protected Adapter(ChainManager<M, ? extends ChainController<M>> mgr) {
      this.manager = mgr;
    }

    /**
     * Set the manager for this controller.
     * 
     * @param mgr
     *        The manager.
     */
    public final void setChainManager(
        ChainManager<M, ? extends ChainController<M>> mgr) {
      this.manager = mgr;
    }

    /**
     * get the manager.
     * 
     * @return the manager.
     */
    public final ChainManager<M, ? extends ChainController<M>> getChainManager() {
      return manager;
    }

    @Override
    public void start(M message) {

    }

    @Override
    public void handleUnhandledMessage(M msg) {
    }

    // SUPPRESS CHECKSTYLE extension
    @Override
    public boolean handleHandledMessage(M msg) {
      getChainManager().setMessageHandled(msg, true);
      getChainManager().terminateMessageHandling(msg);
      return false;
    }

    // SUPPRESS CHECKSTYLE extension
    @Override
    public boolean handleReportedFailure(M msg, ChainHandler<M> handler) {
      getChainManager().terminateMessageHandling(msg);
      return true;
    }

    @Override
    public void submitResult(M msg, ChainHandler<M> handler) {
    }

    @Override
    public void handleTimeout(M msg, ChainHandler<M> handler) {
    }

    @Override
    public void handleInterruptedTask(InterruptedException e, M msg,
        ChainHandler<M> handler) {
    }

    @Override
    public void handleTaskCompleted(M msg, ChainHandler<M> handler) {
    }

    @Override
    public void handleMonitorException(Exception e, M msg,
        ChainHandler<M> handler) {
    }

    @Override
    public void finish(M msg, ChainHandler<M> handler) {
    }

    @Override
    public void handleNullObject(M msg) {
    }

    @Override
    public void handleStartTask(M msg, ChainHandler<M> nextObj) {
    }

    @Override
    public void handleDispatchException(Exception e, M msg,
        ChainHandler<M> handler) {
    }

  }

}